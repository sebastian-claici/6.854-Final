
%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:

\documentclass[12pt]{article}

\usepackage{fullpage}
\usepackage{parskip}

% Maths
\usepackage{amsmath,amssymb,amsthm}

% Algorithms
\usepackage{algpseudocode,algorithm}

\title{From Boston to San Francisco:\\ A Survey of Shortest Paths Algorithms in Planar Graphs}
\author{Stuart Baker, \"{O}mer Cerraho\u{g}lu, Sebastian Claici}
\date{\today}

\begin{document}
\maketitle

\begin{abstract}

\end{abstract}

\section{Introduction}
\label{sec:introduction}

\section{Background}
\label{sec:background}


\section{Single source shortest paths}
\label{sec:single-source-short}

We call an edge $uv$ relaxed if $d(v) \leq d(u) + c(u,v)$. We call the assignment
\[
d(v) \gets \min\{d(v), d(u)+c(u,v)\}
\]
the relaxation of vertex $v$. We know that the labels give a correct shortest path distances if the shortest-path conditions are satisfied:
\begin{itemize}
  \item $d(s) = 0$,
  \item every label $d(v)$ is an upper bound on the $s-v$ distance,
  \item every edge is relaxed.
\end{itemize}

\subsection{Nonnegative edge weights}
\label{sec:nonn-edge-weights}

\subsubsection{Simple algorithm}
\label{sec:simple-algorithm}

For a planar graph with nonnegative edge weights, Dijkstra's algorithm runs in $O(n \log n)$ as $m \leq 3n - 6$. It is possible to improve this to $O(n)$. To get there, recall that and $r$-division of a planar graph is a partition of the graph into $\Theta(n/r)$ regions of size $O(r)$ with boundary size $O(\sqrt{r})$. An $r$-division of a planar graph can be computed in linear time.

A simple $O(n\sqrt{\log n \log \log n})$ emerges quite beautifully just from the $r$-division if we set $r = \frac{\log n}{\log \log n}$. The algorithm follows a divide-and-conquer approach in which each region is processed first, followed by a clean-up phase where the results are merged.

\begin{algorithm}[!htb]
  \caption{Shortest paths in each region $R$}
  \label{alg:sssp-region}
  \begin{algorithmic}
    \ForAll {Regions $R$}
      \ForAll {Boundary nodes $v \in R$}
        \State Compute SSSP from $v$ in $R$
        \State Store $(u,v)$ distances for any two boundary nodes $u$, $v$
      \EndFor
    \EndFor
  \end{algorithmic}
\end{algorithm}

The first step is to compute the single-source shortest paths for each boundary node in each region $R$ (algorithm~\ref{alg:sssp-region}). We can now replace each region $R$ by a complete graph on $R$'s boundary nodes with shortest paths distances between any two nodes. Call this auxiliary graph $G'$. The second phase of the algorithm is to compute the SSSP from $s$ in $G'$. This gives the true shortest paths from $s$ to all the boundary nodes. Finally, we must tidy up by finding the distances from $s$ to the nodes inside each region (algorithm~\ref{alg:sssp-full}).

\begin{algorithm}[!htb]
  \caption{Clean up: shortest paths from $s$ to inside of each region $R$}
  \label{alg:sssp-full}
  \begin{algorithmic}
    \ForAll {Regions $R$}
      \ForAll {Boundary nodes $v \in R$}
        \State Set $d(v) = d_{G'}(s,v)$
        \State Compute SSSP from $v$ in $R$
      \EndFor
    \EndFor
  \end{algorithmic}
\end{algorithm}

To analyze the algorithm, we will need a few pieces of information:
\begin{itemize}
\item Total number of boundary nodes is $O(\sqrt{r})O(n/r) = O(n/\sqrt{r})$.
\item Number of nodes in $G'$ is $O(n/r)O(\sqrt{r})=O(n/\sqrt{r})$.
\item Number of edges in $G'$ is $O(n/r)O(r) = O(n)$.
\end{itemize}

Using $r=\frac{\log n}{\log \log n}$, the first phase is bounded above by
\[
  O\left(n\frac{\sqrt{\log \log n}}{\sqrt{\log n}} \log n\right)= O(n \sqrt{\log n \log \log n}),
\]
the second phase is an SSSP in a size $O(n \frac{\sqrt{\log \log n}}{\sqrt{\log n}})$ graph, and thus also $O(n \sqrt{\log n \log \log n})$, while the tidying up is a series of SSSPs in each of the regions, and has the same bound as the first phase---$O(n \sqrt{\log n \log \log n})$. The total time bound ends up $O(n \sqrt{\log n \log \log n})$.

\subsubsection{Recursion}
\label{sec:recursion}

The key idea that can improve the running time to linear is to go deeper inside the recursive world. Instead of just using an $r$-division of the graph, we recursively subdivide each region until we reach edges which are atomic regions.

The simple algorithm shown above is an improvement over Dijkstra's algorithm, but one can do better. In fact, we can achieve linear time by recursively subdividing the graph. Without loss of generality, assume the graph is directed, and that each node has at most two incoming and two outgoing edges. We call a region atomic if it contains only one edge $uv$. A nonatomic region will have as children subregions that are contained within it.

For each region $R$, we maintain a priority queue $Q(R)$ that stores the subregions of $R$ if $R$ is nonatomic, or the single arc $uv$ is $R$ is atomic. The algorithm ensures that for every region $R$, the minimum element of $Q(R)$ is the minimum label $d(v)$ over all edges $vw$ in $R$ that remain to be processed.

\begin{algorithm}
  \caption{Process region}
  \label{alg:process}
  \begin{algorithmic}
    \Procedure{Process}{}
      \If {$R$ contains only $uv$}
        \If {$d(v) > d(u) + c(u,v)$}
          \State $d(v) \gets d(u) + c(u,v)$
          \State for each outgoing edge $vw$ of $v$, call \Call{Update}{$R(vw),vw,d(v)$}
        \EndIf
        \State $Q(R).updateKey(uv,\infty)$
      \Else
        \Repeat
          \State $R' \gets Q(R).getMin()$
          \State \Call{Process}($R'$)
          \State $Q(R).updateKey(R',Q(R').getMinKey())$
        \Until {$Q(R).getMinKey()$ is infinity or if repeated $\alpha_{h(R)}$ times}
      \EndIf
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{Update region}
  \label{alg:update}
  \begin{algorithmic}
    \Procedure{Update}{$R,x,k$}
      \State $Q(R).updateKey(x,k)$
      \If {$updateKey$ reduced the value of $Q(R).getMinKey()$}
        \State \Call{Update}($parent(R),R,k$)
      \EndIf
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

The procedures are used in algorithm~\ref{alg:linear}.

\begin{algorithm}
  \label{alg:linear}
  \caption{Faster SSSP}
  \begin{algorithmic}
    \State Find recursive subdivision $R(G), R(P_i), \ldots, R(uv)$
    \State Allocate queue $Q$ for each region
    \State $d(v) \gets \infty, \forall v$
    \State $d(s) \gets 0$
    \ForAll {$sv \in E(G)$}
      \State \Call{Update}{$R(sv),sv,0$}
    \EndFor
    \While {$Q(R(G)).getMinKey() < \infty$}
      \State \Call{Process}{$R(G)$}
    \EndWhile
  \end{algorithmic}
\end{algorithm}

By playing around with the number of levels, number of nodes per region per level, and the $\alpha_i$, we can achieve linear time. To give an intuition, we present here a $O(n \log \log n)$ algorithm and briefly comment on how to change it to get rid of the $\log \log n$ factor.

\subsection{Arbitrary edge weights}
\label{sec:arbitr-edge-weights}

\section{Multiple source shortest paths}
\label{sec:mult-source-short}

\section{Extensions to higher genus}
\label{sec:extens-high-genus}


\bibliographystyle{plain}
\bibliography{proposal}
\end{document}